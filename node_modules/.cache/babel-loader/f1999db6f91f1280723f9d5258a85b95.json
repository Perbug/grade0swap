{"ast":null,"code":"import _regeneratorRuntime from\"/Users/xcodedeveloper/Desktop/grade0swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/xcodedeveloper/Desktop/grade0swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{Contract,ethers}from\"ethers\";import*as chains from\"./constants/chains\";import COINS from\"./constants/coins\";var ROUTER=require(\"./build/UniswapV2Router02.json\");var ERC20=require(\"./build/ERC20.json\");var FACTORY=require(\"./build/IUniswapV2Factory.json\");var PAIR=require(\"./build/IUniswapV2Pair.json\");export function getProvider(){return new ethers.providers.Web3Provider(window.ethereum);}export function getSigner(provider){return provider.getSigner();}export function getNetwork(_x){return _getNetwork.apply(this,arguments);}function _getNetwork(){_getNetwork=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(provider){var network;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return provider.getNetwork();case 2:network=_context.sent;return _context.abrupt(\"return\",network.chainId);case 4:case\"end\":return _context.stop();}}},_callee);}));return _getNetwork.apply(this,arguments);}export function getRouter(address,signer){return new Contract(address,ROUTER.abi,signer);}export function checkNetwork(_x2){return _checkNetwork.apply(this,arguments);}function _checkNetwork(){_checkNetwork=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(provider){var chainId;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:chainId=getNetwork(provider);if(!chains.networks.includes(chainId)){_context2.next=3;break;}return _context2.abrupt(\"return\",true);case 3:return _context2.abrupt(\"return\",false);case 4:case\"end\":return _context2.stop();}}},_callee2);}));return _checkNetwork.apply(this,arguments);}export function getWeth(address,signer){return new Contract(address,ERC20.abi,signer);}export function getFactory(address,signer){return new Contract(address,FACTORY.abi,signer);}export function getAccount(){return _getAccount.apply(this,arguments);}//This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\nfunction _getAccount(){_getAccount=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){var accounts;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return window.ethereum.request({method:\"eth_requestAccounts\"});case 2:accounts=_context3.sent;return _context3.abrupt(\"return\",accounts[0]);case 4:case\"end\":return _context3.stop();}}},_callee3);}));return _getAccount.apply(this,arguments);}export function doesTokenExist(address,signer){try{return new Contract(address,ERC20.abi,signer);}catch(err){return false;}}export function getDecimals(_x3){return _getDecimals.apply(this,arguments);}// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\nfunction _getDecimals(){_getDecimals=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(token){var decimals;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return token.decimals().then(function(result){return result;}).catch(function(error){console.log('No tokenDecimals function for this token, set to 0');return 0;});case 2:decimals=_context4.sent;return _context4.abrupt(\"return\",decimals);case 4:case\"end\":return _context4.stop();}}},_callee4);}));return _getDecimals.apply(this,arguments);}export function getBalanceAndSymbol(_x4,_x5,_x6,_x7,_x8,_x9){return _getBalanceAndSymbol.apply(this,arguments);}// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\nfunction _getBalanceAndSymbol(){_getBalanceAndSymbol=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(accountAddress,address,provider,signer,weth_address,coins){var balanceRaw,token,tokenDecimals,_balanceRaw,symbol;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.prev=0;if(!(address===weth_address)){_context5.next=8;break;}_context5.next=4;return provider.getBalance(accountAddress);case 4:balanceRaw=_context5.sent;return _context5.abrupt(\"return\",{balance:ethers.utils.formatEther(balanceRaw),symbol:coins[0].abbr});case 8:token=new Contract(address,ERC20.abi,signer);_context5.next=11;return getDecimals(token);case 11:tokenDecimals=_context5.sent;_context5.next=14;return token.balanceOf(accountAddress);case 14:_balanceRaw=_context5.sent;_context5.next=17;return token.symbol();case 17:symbol=_context5.sent;return _context5.abrupt(\"return\",{balance:_balanceRaw*Math.pow(10,-tokenDecimals),symbol:symbol});case 19:_context5.next=26;break;case 21:_context5.prev=21;_context5.t0=_context5[\"catch\"](0);console.log('The getBalanceAndSymbol function had an error!');console.log(_context5.t0);return _context5.abrupt(\"return\",false);case 26:case\"end\":return _context5.stop();}}},_callee5,null,[[0,21]]);}));return _getBalanceAndSymbol.apply(this,arguments);}export function swapTokens(_x10,_x11,_x12,_x13,_x14,_x15){return _swapTokens.apply(this,arguments);}//This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\nfunction _swapTokens(){_swapTokens=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(address1,address2,amount,routerContract,accountAddress,signer){var tokens,time,deadline,token1,tokenDecimals,amountIn,amountOut,wethAddress;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:tokens=[address1,address2];time=Math.floor(Date.now()/1000)+200000;deadline=ethers.BigNumber.from(time);token1=new Contract(address1,ERC20.abi,signer);_context6.next=6;return getDecimals(token1);case 6:tokenDecimals=_context6.sent;amountIn=ethers.utils.parseUnits(amount,tokenDecimals);_context6.next=10;return routerContract.callStatic.getAmountsOut(amountIn,tokens);case 10:amountOut=_context6.sent;_context6.next=13;return token1.approve(routerContract.address,amountIn);case 13:_context6.next=15;return routerContract.WETH();case 15:wethAddress=_context6.sent;if(!(address1===wethAddress)){_context6.next=21;break;}_context6.next=19;return routerContract.swapExactETHForTokens(amountOut[1],tokens,accountAddress,deadline,{value:amountIn});case 19:_context6.next=28;break;case 21:if(!(address2===wethAddress)){_context6.next=26;break;}_context6.next=24;return routerContract.swapExactTokensForETH(amountIn,amountOut[1],tokens,accountAddress,deadline);case 24:_context6.next=28;break;case 26:_context6.next=28;return routerContract.swapExactTokensForTokens(amountIn,amountOut[1],tokens,accountAddress,deadline);case 28:case\"end\":return _context6.stop();}}},_callee6);}));return _swapTokens.apply(this,arguments);}export function getAmountOut(_x16,_x17,_x18,_x19,_x20){return _getAmountOut.apply(this,arguments);}// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\nfunction _getAmountOut(){_getAmountOut=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(address1,address2,amountIn,routerContract,signer){var token1,token1Decimals,token2,token2Decimals,values_out,amount_out;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.prev=0;token1=new Contract(address1,ERC20.abi,signer);_context7.next=4;return getDecimals(token1);case 4:token1Decimals=_context7.sent;token2=new Contract(address2,ERC20.abi,signer);_context7.next=8;return getDecimals(token2);case 8:token2Decimals=_context7.sent;_context7.next=11;return routerContract.getAmountsOut(ethers.utils.parseUnits(String(amountIn),token1Decimals),[address1,address2]);case 11:values_out=_context7.sent;amount_out=values_out[1]*Math.pow(10,-token2Decimals);console.log('amount out: ',amount_out);return _context7.abrupt(\"return\",Number(amount_out));case 17:_context7.prev=17;_context7.t0=_context7[\"catch\"](0);return _context7.abrupt(\"return\",false);case 20:case\"end\":return _context7.stop();}}},_callee7,null,[[0,17]]);}));return _getAmountOut.apply(this,arguments);}export function fetchReserves(_x21,_x22,_x23,_x24){return _fetchReserves.apply(this,arguments);}// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\nfunction _fetchReserves(){_fetchReserves=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(address1,address2,pair,signer){var coin1,coin2,coin1Decimals,coin2Decimals,reservesRaw,results;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_context8.prev=0;// Get decimals for each coin\ncoin1=new Contract(address1,ERC20.abi,signer);coin2=new Contract(address2,ERC20.abi,signer);_context8.next=5;return getDecimals(coin1);case 5:coin1Decimals=_context8.sent;_context8.next=8;return getDecimals(coin2);case 8:coin2Decimals=_context8.sent;_context8.next=11;return pair.getReserves();case 11:reservesRaw=_context8.sent;_context8.next=14;return pair.token0();case 14:_context8.t0=_context8.sent;_context8.t1=address1;if(!(_context8.t0===_context8.t1)){_context8.next=20;break;}_context8.t2=reservesRaw[0];_context8.next=21;break;case 20:_context8.t2=reservesRaw[1];case 21:_context8.t3=_context8.t2;_context8.next=24;return pair.token1();case 24:_context8.t4=_context8.sent;_context8.t5=address2;if(!(_context8.t4===_context8.t5)){_context8.next=30;break;}_context8.t6=reservesRaw[1];_context8.next=31;break;case 30:_context8.t6=reservesRaw[0];case 31:_context8.t7=_context8.t6;results=[_context8.t3,_context8.t7];return _context8.abrupt(\"return\",[results[0]*Math.pow(10,-coin1Decimals),results[1]*Math.pow(10,-coin2Decimals)]);case 36:_context8.prev=36;_context8.t8=_context8[\"catch\"](0);console.log(\"error!\");console.log(_context8.t8);return _context8.abrupt(\"return\",[0,0]);case 41:case\"end\":return _context8.stop();}}},_callee8,null,[[0,36]]);}));return _fetchReserves.apply(this,arguments);}export function getReserves(_x25,_x26,_x27,_x28,_x29){return _getReserves.apply(this,arguments);}function _getReserves(){_getReserves=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(address1,address2,factory,signer,accountAddress){var pairAddress,pair,reservesRaw,liquidityTokens_BN,liquidityTokens;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.prev=0;_context9.next=3;return factory.getPair(address1,address2);case 3:pairAddress=_context9.sent;pair=new Contract(pairAddress,PAIR.abi,signer);if(!(pairAddress!=='0x0000000000000000000000000000000000000000')){_context9.next=16;break;}_context9.next=8;return fetchReserves(address1,address2,pair,signer);case 8:reservesRaw=_context9.sent;_context9.next=11;return pair.balanceOf(accountAddress);case 11:liquidityTokens_BN=_context9.sent;liquidityTokens=Number(ethers.utils.formatEther(liquidityTokens_BN));return _context9.abrupt(\"return\",[reservesRaw[0].toPrecision(6),reservesRaw[1].toPrecision(6),liquidityTokens]);case 16:console.log(\"no reserves yet\");return _context9.abrupt(\"return\",[0,0,0]);case 18:_context9.next=25;break;case 20:_context9.prev=20;_context9.t0=_context9[\"catch\"](0);console.log(\"error!\");console.log(_context9.t0);return _context9.abrupt(\"return\",[0,0,0]);case 25:case\"end\":return _context9.stop();}}},_callee9,null,[[0,20]]);}));return _getReserves.apply(this,arguments);}","map":{"version":3,"sources":["/Users/xcodedeveloper/Desktop/grade0swap/src/ethereumFunctions.js"],"names":["Contract","ethers","chains","COINS","ROUTER","require","ERC20","FACTORY","PAIR","getProvider","providers","Web3Provider","window","ethereum","getSigner","provider","getNetwork","network","chainId","getRouter","address","signer","abi","checkNetwork","networks","includes","getWeth","getFactory","getAccount","request","method","accounts","doesTokenExist","err","getDecimals","token","decimals","then","result","catch","error","console","log","getBalanceAndSymbol","accountAddress","weth_address","coins","getBalance","balanceRaw","balance","utils","formatEther","symbol","abbr","tokenDecimals","balanceOf","swapTokens","address1","address2","amount","routerContract","tokens","time","Math","floor","Date","now","deadline","BigNumber","from","token1","amountIn","parseUnits","callStatic","getAmountsOut","amountOut","approve","WETH","wethAddress","swapExactETHForTokens","value","swapExactTokensForETH","swapExactTokensForTokens","getAmountOut","token1Decimals","token2","token2Decimals","String","values_out","amount_out","Number","fetchReserves","pair","coin1","coin2","coin1Decimals","coin2Decimals","getReserves","reservesRaw","token0","results","factory","getPair","pairAddress","liquidityTokens_BN","liquidityTokens","toPrecision"],"mappings":"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","sourcesContent":["import { Contract, ethers } from \"ethers\";\r\nimport * as chains from \"./constants/chains\";\r\nimport COINS from \"./constants/coins\";\r\n\r\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\r\nconst ERC20 = require(\"./build/ERC20.json\");\r\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\r\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\r\n\r\nexport function getProvider() {\r\n  return new ethers.providers.Web3Provider(window.ethereum);\r\n}\r\n\r\nexport function getSigner(provider) {\r\n  return provider.getSigner();\r\n}\r\n\r\nexport async function getNetwork(provider) {\r\n  const network = await provider.getNetwork();\r\n  return network.chainId;\r\n}\r\n\r\nexport function getRouter(address, signer) {\r\n  return new Contract(address, ROUTER.abi, signer);\r\n}\r\n\r\nexport async function checkNetwork(provider) {\r\n  const chainId = getNetwork(provider);\r\n  if (chains.networks.includes(chainId)){\r\n    return true\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function getWeth(address, signer) {\r\n  return new Contract(address, ERC20.abi, signer);\r\n}\r\n\r\nexport function getFactory(address, signer) {\r\n  return new Contract(address, FACTORY.abi, signer);\r\n}\r\n\r\nexport async function getAccount() {\r\n  const accounts = await window.ethereum.request({\r\n    method: \"eth_requestAccounts\",\r\n  });\r\n\r\n  return accounts[0];\r\n}\r\n\r\n//This function checks if a ERC20 token exists for a given address\r\n//    `address` - The Ethereum address to be checked\r\n//    `signer` - The current signer\r\nexport function doesTokenExist(address, signer) {\r\n  try {\r\n    return new Contract(address, ERC20.abi, signer);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function getDecimals(token) {\r\n  const decimals = await token.decimals().then((result) => {\r\n      return result;\r\n    }).catch((error) => {\r\n      console.log('No tokenDecimals function for this token, set to 0');\r\n      return 0;\r\n    });\r\n    return decimals;\r\n}\r\n\r\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\r\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\r\n//    `provider` - The current provider\r\n//    `signer` - The current signer\r\nexport async function getBalanceAndSymbol(\r\n  accountAddress,\r\n  address,\r\n  provider,\r\n  signer,\r\n  weth_address,\r\n  coins\r\n) {\r\n  try {\r\n    if (address === weth_address) {\r\n      const balanceRaw = await provider.getBalance(accountAddress);\r\n\r\n      return {\r\n        balance: ethers.utils.formatEther(balanceRaw),\r\n        symbol: coins[0].abbr,\r\n      };\r\n    } else {\r\n      const token = new Contract(address, ERC20.abi, signer);\r\n      const tokenDecimals = await getDecimals(token);\r\n      const balanceRaw = await token.balanceOf(accountAddress);\r\n      const symbol = await token.symbol();\r\n\r\n      return {\r\n        balance: balanceRaw*10**(-tokenDecimals),\r\n        symbol: symbol,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.log ('The getBalanceAndSymbol function had an error!');\r\n    console.log (error)\r\n    return false;\r\n  }\r\n}\r\n\r\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\r\n// No error handling is done, so any issues can be caught with the use of .catch()\r\n// To work correctly, there needs to be 7 arguments:\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `amount` - A float or similar number representing the value of address1's token to trade\r\n//    `routerContract` - The router contract to carry out this trade\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `signer` - The current signer\r\nexport async function swapTokens(\r\n  address1,\r\n  address2,\r\n  amount,\r\n  routerContract,\r\n  accountAddress,\r\n  signer\r\n) {\r\n  const tokens = [address1, address2];\r\n  const time = Math.floor(Date.now() / 1000) + 200000;\r\n  const deadline = ethers.BigNumber.from(time);\r\n\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const tokenDecimals = await getDecimals(token1);\r\n  \r\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\r\n  const amountOut = await routerContract.callStatic.getAmountsOut(\r\n    amountIn,\r\n    tokens\r\n  );\r\n\r\n  await token1.approve(routerContract.address, amountIn);\r\n  const wethAddress = await routerContract.WETH();\r\n\r\n  if (address1 === wethAddress) {\r\n    // Eth -> Token\r\n    await routerContract.swapExactETHForTokens(\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline,\r\n      { value: amountIn }\r\n    );\r\n  } else if (address2 === wethAddress) {\r\n    // Token -> Eth\r\n    await routerContract.swapExactTokensForETH(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  } else {\r\n    await routerContract.swapExactTokensForTokens(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  }\r\n}\r\n\r\n//This function returns the conversion rate between two token addresses\r\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\r\n//    `amountIn` - Amount of the token at address 1 to be swaped from\r\n//    `routerContract` - The router contract to carry out this swap\r\nexport async function getAmountOut(\r\n  address1,\r\n  address2,\r\n  amountIn,\r\n  routerContract,\r\n  signer\r\n) {\r\n  try {\r\n    const token1 = new Contract(address1, ERC20.abi, signer);\r\n    const token1Decimals = await getDecimals(token1);\r\n\r\n    const token2 = new Contract(address2, ERC20.abi, signer);\r\n    const token2Decimals = await getDecimals(token2);\r\n\r\n    const values_out = await routerContract.getAmountsOut(\r\n      ethers.utils.parseUnits(String(amountIn), token1Decimals),\r\n      [address1, address2]\r\n    );\r\n    const amount_out = values_out[1]*10**(-token2Decimals);\r\n    console.log('amount out: ', amount_out)\r\n    return Number(amount_out);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\r\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\r\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\r\n//    `pair` - The pair contract for the two tokens\r\nexport async function fetchReserves(address1, address2, pair, signer) {\r\n  try {\r\n\r\n    // Get decimals for each coin\r\n    const coin1 = new Contract(address1, ERC20.abi, signer);\r\n    const coin2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n    const coin1Decimals = await getDecimals(coin1);\r\n    const coin2Decimals = await getDecimals(coin2);\r\n\r\n    // Get reserves\r\n    const reservesRaw = await pair.getReserves();\r\n\r\n    // Put the results in the right order\r\n    const results =  [\r\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\r\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\r\n    ];\r\n\r\n    // Scale each to the right decimal place\r\n    return [\r\n      (results[0]*10**(-coin1Decimals)),\r\n      (results[1]*10**(-coin2Decimals))\r\n    ]\r\n  } catch (err) {\r\n    console.log(\"error!\");\r\n    console.log(err);\r\n    return [0, 0];\r\n  }\r\n}\r\n\r\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `factory` - The current factory\r\n//    `signer` - The current signer\r\nexport async function getReserves(\r\n  address1,\r\n  address2,\r\n  factory,\r\n  signer,\r\n  accountAddress\r\n) {\r\n  try {\r\n    const pairAddress = await factory.getPair(address1, address2);\r\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n  \r\n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\r\n  \r\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\r\n      const liquidityTokens_BN = await pair.balanceOf(accountAddress);\r\n      const liquidityTokens = Number(\r\n        ethers.utils.formatEther(liquidityTokens_BN)\r\n      );\r\n    \r\n      return [\r\n        reservesRaw[0].toPrecision(6),\r\n        reservesRaw[1].toPrecision(6),\r\n        liquidityTokens,\r\n      ];\r\n    } else {\r\n      console.log(\"no reserves yet\");\r\n      return [0,0,0];\r\n    }\r\n  }catch (err) {\r\n    console.log(\"error!\");\r\n    console.log(err);\r\n    return [0, 0, 0];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}